## 1. 알고리즘 분석
### 정확성 분석
- 유효한 입력에 대해 유한 시간 내에 정확한 결과의 생성 여부
    - 수학적 기법을 사용한 이론적인 증명 과정

### 효율성 분석
- 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정/평가
- 공간 복잡도
    - 메모리의 양 = 정적 공간 + 동적 공간

- 시간 복잡도
    - 수행시간 = 알고리즘의 실행에서부터 완료까지 걸리는 시간
### 시간 복잡도
- 컴퓨터에서 실행시켜 실제 수행시간을 측정하는 방법?
    - 실행 환경에 종속적이므로 일반성이 결여된 방법
        - 컴퓨터 속도, 구현에 사용된 프로그래밍 언어, 프로그램 작성 방법, 컴파일러의 효율성 등에 따라 시간이 달라짐
- 알고리즘 수행시간 = Σ{각 문장(연산)이 수행되는 획수}
    - 수행시간에 영향을 미치는 요인
        - 입력크기
            - 입력되는 데이터의 크기, 문제해결하려는 대상이 되는 개체의 개수
        - 입력 데이터의 상태
- 입력크기 n이 커질수록 수행시간도 증가
    - 단순히 단위 연산이 수행되는 개수의 합으로 표현하는 것은 부적절
        - 입력 크기 n의 함수 f(n)으로 표현
- 입력 데이터의 상태에 종속적
    - 평균 수행시간
    - 최선 수행시간
    - 최악 수행시간

## 2. 점근성능
### 입력 크기 n이 무한히 커짐에 따라 결정되는 성능
### 점근성능의 결정 방법
- 입력 크기가 충분히 커짐에 따라 함숫값에 가장 큰 영향을 미치는 차수를 찾음
- 수행시간의 다항식 함수에서 최고차항만을 계수 없이 취해서 표현
    - 수행시간의 정확한 값이 아닌 어림 값
        - 수행시간의 증가 추세를 파악하는 것이 쉬움
        - 알고리즘 간의 우열을 따질 떄 유용
### 알고리즘의 시간 복잡도 구하기
- 알고리즘의 시간 복잡도를 구하려면
    - 기본 연산의 수행 횟수의 합 f(n)을 구한 후
    - f(n) = O(g(n))을 만족하는 최소 차수의 함수 g(n)을 찾음
- 실용적인 접근 방법
    - 알고리즘의 모든 ㅜㅁㄴ장이 아닌 루프의 반복 횟수만을 조사하여 최고 차수를 시간 복잡도로 취함

## 3. 순환 알고리즘
- 순환, 재귀 알고리즘
    - 알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태

## 정리하기
1. 알고리즘 분석

⦁ 알고리즘 분석 → 정확성 분석, 효율성 분석

⦁ 정확성 분석 → 올바른 입력이 주어졌을 때 유한 시간 내에 정확한 결과를 생성하는 지를 수학적으로 증명하는 것

⦁ 효율성 분석 → 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정

- 공간 복잡도 → 알고리즘 수행에 필요한 총 메모리의 양
- 시간 복잡도 → 알고리즘의 수행시간

⦁ 알고리즘 수행시간 → 알고리즘의 각 단위 연산(문장)이 수행되는 횟수의 합

- 입력 크기의 함수로 표현
- 데이터의 입력 상태에 따라 달라짐 → 최악의 수행시간으로 표현

2. 점근성능

⦁ 입력 크기가 무한히 커짐에 따라 결정되는 성능

- 수행시간의 다항식 함수에서 최고차항만을 계수 없이 취해서 단순하게 표현하는 방법 → 알고리즘 수행시간의 증가 추세를 나타내므로 알고리즘 간의 우열 표현/비교에 용이
- 요소 → 시작

⦁ 표기법
- O-표기(“Big-oh”) → 점근적 상한 → 알고리즘의 최악의 수행시간에 해당
- Ω-표기(“Big-omega”) → 점근적 하한 → 최선의 수행시간에 해당
- Θ-표기(“Big-theta”) → 점근적 상한과 하한을 동시에 표시

⦁ O–표기의 함수 간의 크기 관계 → O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n)

⦁ 실용적인 계산 방법 → 알고리즘에 나타난 루프(반복문)의 반복횟수를 조사하여 최고 차수를 시간 복잡도로 취함

3. 순환 알고리즘

⦁ 알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 호출하여 수행하는 형태의 알고리즘

- 수행시간은 점화식으로 표현되고, 이를 풀어서 폐쇄형으로 표시
- 분할정복 방법의 적용된 알고리즘(이진 탐색, 퀵 정렬, 합병 정렬)은 기본적으로 순환 
알고리즘 형태로 표현됨

⦁ 기본적인 점화식과 폐쇄형

① T(n) = T(n-1) + Θ(1), T(1)=Θ(1) → T(n) = Θ(n)

② T(n) = T(n-1) + Θ(n), T(1)=Θ(1) → T(n) = Θ(n2) → 퀵 정렬의 최악 수행 시간

③ T(n) = T(n/2) + Θ(1), T(1)=Θ(1) → T(n) = Θ(logn) → 이진 탐색의 수행 시간

④ T(n) = T(n/2) + Θ(n), T(1)=Θ(1) → T(n) = Θ(n)

⑤ T(n) = 2T(n/2) + Θ(1), T(1)=Θ(1) → T(n) = Θ(n)

⑥ T(n) = 2T(n/2) + Θ(n), T(1)=Θ(1) → T(n) = Θ(nlogn) → 퀵 정렬의 최선 수행 시간, 합병 정렬의 수행 시간
