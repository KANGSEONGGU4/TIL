>   ## 명령코드(operation code)
>명령코드는 명령어가 수행할 연산을 의미합니다. 명령 코드 종류는 매우 많지만, 가장 기본적인 명령 코드 유형은 크게 4가지 기능으로 나눌 수 있습니다.

### 명령어 코드 기능

1. 데이터 전송
    - MOVE : 데이터를 옮겨라
    - STORE : 메모리에 저장하라
    - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
    - PUSH : 스택에 데이터를 저장하라
    - POP : 스택의 최상단 데이터를 가져와라
2. 산술/논리 연산
    - ADD/SUBTRACT/MULTIPLY/DIVIDE : 덧셈/뺄셈/곱셈/나눗셈
    - INCREMENT/DECREMENT : 오퍼랜드에 1을 더하라/빼라
    - AND/OR/NOT : 논리 연산을 수행하라
    - COMPARE: 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라
3. 제어 흐름 변경
    - JUMP : 특정 주소로 실행순서를 옮겨라
    - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
    - HALT : 프로그램의 실행을 멈춰라
    - CALL : 되돌아올 주소를 저장할 채 특정 주소로 실행 순서를 옮겨라
    - RETURN : CALL을 호출할 때 저장했떤 주소로 돌아가라
4. 입출력 제어
    - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
    - WRTIE(OUTPUT) : 특정 입출력 장치로부터 데이터를 써라
    - START IO : 입출력 장치를 시작하라
    - TEST IO : 입출력 장치의 상태를 확인하라


### 주소 수에 따른 명령어 형식

#### 0-주소 명령어 형식
  - 스택(Stack) 구조 컴퓨터에서 사용되는 명령어 형식입니다.
  - 입력 자료들의 출처와 연산 결과를 기억시킬 장소가 고정되어 있습니다.
  - 명령어 내에서 자료의 주소를 지정할 필요가 없는 명령어 형식입니다.
  - TOS는 스택의 최상단을 의미합니다.
#### 1-주소 명령어 형식
 - 단일 누산기 구조의 컴퓨터에서 사용됩니다.
 - 명령어의 수행은 누산기(AC) 레지스터에서 이루어집니다. 
 - 하나의 주소부를 가지며, 연산에 사용되는 피연산자는 명령어에 나타난 주소부에 의하여 얻어지는 
   피연산자와 누산기에 기억되어 있는 피연산자입니다.
 - 연산 결과도 누산기에 저장되므로 
   명령어 실행 이전에 기억되어 있던 데이터는 명령어 실행 후에 잃어버립니다.
#### 2-주소 명령어 형식
 - 범용 레지스터 구조의 컴퓨터에서 사용되며, 가장 많이 사용하는 형식입니다.
 - 각 주소부는 레지스터나 주기억 장치의 주소를 지정합니다.
 - 연산 후 입력 자료의 보존이 필요 없으면 
   연산 결과를 두 개의 입력 자료가 기억되어 있던 곳들 중 한 레지스터에 기억시키는 방식입니다.
#### 3-주소 명령어 형식
 - 범용 레지스터 구조의 컴퓨터에서 사용되며, 세 개의 주소를 지정합니다.
 - 각 주소부는 레지스터나 주기억 장치의 주소를 지정합니다.
 - 프로그램의 길이가 짧고 연산 후에 입력 자료가 레지스터에 보존되는 장점이 있습니다.
 - 하나의 명령을 수행하기 위해서는 자주 기억 장치에 접근해야 하므로
   수행 시간이 길어져 특수 목적의 기계 외에는 사용을 하지 않습니다.

>   ## 오퍼랜드(operand)
>   오퍼랜드는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미합니다. 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있습니다.   
>   오퍼랜드는 또 다른 말로 주소 필드라고 합니다. 명령어 길이 때문에 많은 경우 데이터를 직접명시하기 보다는 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름을 담기 때문입니다.   
명령어가 n비트로 구성되어 있고 명령 코드 필드가 m비트라면 오퍼랜드 최대 길이가 n-m, 오퍼랜드 갯수가 늘어나면 표현할 수 있는 정보의 가짓수가 제한이 있습니다. 하지만 오퍼랜드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 메모리 주소에 저장할 수 있는 공간만큼 늘어나게 됩니다.

### 1. 즉시 주소 지정방식

명령에 사용할 데이터를 오퍼랜드 필드 자체 내에 포함되어 있는 형태로 명령이 인출됨과 동시에 바로 명령어의 실행이 바로 이루어지는 방식이다.   
데이터의 크기가 작아진다는 단점이 있지만 연산에 사용할 데이터를 메모리나 레지스터로부터 찾을 필요가 없기 때문에 가장 빠릅니다.

### 2. 직접 주소 지정방식

오퍼랜드 내의 주소를 실제 데이터의 주소로 직접 표현하는 방식으로, 분기 형식의 명령에서 주로 사용된다.   
장점은 기억 장치상의 주소와 프로그램상의 주소가 일치하기 때문에 프로그램이 간결하게 작성되고, 간접 주소 지정 방식이 비해 속도가 빠르다.   
단점은 기억 장치의 용량이 큰 경우 오퍼랜드의 길이가 길어져 융통성이 부족하다.

### 3. 간접 주소 지정방식

유효 주소의 주소를 오퍼랜드 필드에 표현하는 방식입니다.   
오퍼랜드의 주소부에 의해 기억 장치 내의 주소로 찾아간 후, 그 주소의 내용이 나타내는 주소에 실제 데이터가 기억된다. 실제 유효 주소를 구하기 위하여 한 번은 유효 주소를 가져오고, 한 번은 유효 주소로부터 실제 데이터를 가져오는 두 번의 메모리 참조가 수행된다.   
장점은 오퍼랜드의 짧은 길이로 긴 주소를 접근할 수 있어 기억 장치의 용량이 큰 경우도 융통성이 보장된다. 단점은 기억 장치에 두 번 이상 접근해야하기 때문에 데이터 처리 속도가 느리다.

### 4. 레지스터 주소 지정방식

중앙 처리 장치 내의 레지스터에 실제 데이터가 기억되어 있는 방식이다.   
명령어의 주소부는 지정된 레지스터의 번호를 가진다. 데이터 인출을 위해 주기억 장치에 접근할 필요가 없기 때문에 명령어 실행시간이 빨라지지만 내부 레지스터들로 제한되어 사용한다.

### 5. 레지스터 간접 주소 지정방식

간접 주소 지정 방식과 레지스터 주소 방식을 혼합하여 만든 방식이다.   
오퍼랜드가 레지스터를 저장하고, 그 레지스터의 값이 실제 데이터가 기억된 주소를 지정한다.

### 6. 묵시적 주소지정 방식, 스택 주소 지정방식

묵시적 주소 지정 방식은 명령어에서 주소 필드를 필요로 하지 않는 방식입니다.  연산코드 필드에 지정된 묵시적인 오퍼랜드를 사용한다. 스택에서 스택포인터를 이용한 주소 지정 방식이라고 보면 된다.

### 7. 변위 주소 지정방식 - 상대 주소 지정방식

변위 주소 지정방식은 오퍼랜드의 필드 값(변위)와 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식으로 상대 주소 지정방식은 프로그램 카운터의 값과 오퍼랜드를 더해서 유효 주소를 얻는 방식입니다. PC에 들어 잇는 명령어의 주소를 기준으로 오퍼랜드(음수,양수)만큼 건너뛴 번지를 실행합니다.

### 8. 변위 주소 지정방식 - 베이스 레지스터 주소 지정방식

베이스 레지스터 주소 지정방식은 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 만드는 방식입니다. 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어냅니다.

